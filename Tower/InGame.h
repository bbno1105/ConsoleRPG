#pragma once
#include "Common.h"

class InGame
{
private:
	int selectMenu = 0;

	int nowMenu[7] = { 3, 3, 2, 1, 2, 3, 3 };
	int menuState = 0;

	string Menu[7][3] = { { "단련하기", "아르바이트", "탐험하기" },
						  { "기초체력(-100G)", "주먹단련(-150G)", "책읽기(-150G)" },
						  { "농장(100G)", "음식점(50~150G)", "" },
						  { "탑 오르기", "", "" },
						  { "왼쪽", "오른쪽", "" },
						  { "공격하기", "대화하기", "도망가기" },
						  { "1번", "2번", "3번" } };

	string text[4] = { "" };

	string QuizData[9][4] =
	{
		{"함정이 나타났다! 다음 중 카멜 표기법을 올바르게 표기한 것은", "1. camelcase", "2. camel_case", "3. camelCase"},
		{"함정이 나타났다! if(0){int a = 0} 다음에서 발생할 수 있는 오류는?", "1. 컴파일 오류", "2. 런타임 오류", "3. 링크 오류"},
		{"함정이 나타났다! git에서 특정 버전을 불러오는 명령어는?", "1. commit", "2. checkout", "3. merge"},
		  
		{"함정이 나타났다! 소스프로그램을 목적프로그램으로 변환하는 작업은?", "1. 링크", "2. 컴파일", "3. 코딩"},
		{"함정이 나타났다! 객체의 속성이 아닌 것은?", "1. 타입", "2. 수명", "3. 나이"},
		{"함정이 나타났다! 포인터에 대한 설명이 틀린 것은?", "1. 포인터는 주소를 값으로 갖는다.", "2. void*는 역참조를 통해 값을 다룰 수 있다.", "3. 포인터는 NULL 값이 포함될 수 있다."},
		  
		{"함정이 나타났다! SOLID 원칙에 해당하지 않는 것은?", "1. 단일 책임의 원칙", "2. 명확성의 원칙", "3. 의존성 역전 원칙"},
		{"함정이 나타났다! 올바르게 설명한 내용은?", "1. 명시적 변환은 데이터의 손실이 발생할 수 있다.", "2. 함수 내부에서 선언된 변수는 힙에 저장된다.", "3. 주소값의 크기는 항상 일정하다." },
		{"함정이 나타났다! 동적할당에 대해 올바르지 않는 것은?", "1. delete에서는 free을 실행한다.", "2. 메모리를 반환하여 댕글링 포인터의 발생을 방지할 수 있다.", "3. class 타입에 new를 사용하면 생성자를 호출한다."}
	};

	int QuizAnswer[9] = { 2, 0, 1, 1, 2, 1, 1, 0, 1 };

public:
	void Init();
	void Update();
	void Render();
	void Release();

private:
	void Training();
	void Work();
	void Travel();
	void Tower();
	void Monsters();
	void Quiz();
};

__declspec(selectany) InGame inGame;